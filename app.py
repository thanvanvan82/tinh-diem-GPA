import streamlit as st
import pandas as pd
from typing import Dict, List, Tuple
import matplotlib.pyplot as plt
import numpy as np

st.set_page_config(page_title="H·ªá th·ªëng T∆∞ v·∫•n H·ªçc t·∫≠p", page_icon="üéì", layout="wide")

# -----------------------------
# D·ªÆ LI·ªÜU C·∫§U H√åNH & H·∫∞NG S·ªê
# -----------------------------
PRESET_SCALES: Dict[str, Dict[str, float]] = {
    "VN 4.0 (TLU)": {"A": 4.0, "B": 3.0, "C": 2.0, "D": 1.0, "F": 0.0},
    "Simple 10-point": {str(k): float(k) for k in range(10, -1, -1)},
    "US 4.0 (with +/-)": {"A+": 4.0, "A": 4.0, "A-": 3.7, "B+": 3.3, "B": 3.0, "B-": 2.7, "C+": 2.3, "C": 2.0, "C-": 1.7, "D+": 1.3, "D": 1.0, "D-": 0.7, "F": 0.0},
}

# N√ÇNG C·∫§P: D·ªØ li·ªáu ƒë∆∞·ª£c tr√≠ch xu·∫•t t·ª´ h√¨nh ·∫£nh ch∆∞∆°ng tr√¨nh ƒë√†o t·∫°o
DEFAULT_COURSE_CATEGORIES = [
    "L√Ω lu·∫≠n ch√≠nh tr·ªã",
    "K·ªπ nƒÉng",
    "Ngo·∫°i ng·ªØ",
    "Khoa h·ªçc t·ª± nhi√™n v√† tin h·ªçc",
    "Gi√°o d·ª•c qu·ªëc ph√≤ng an ninh",
    "Gi√°o d·ª•c th·ªÉ ch·∫•t",
    "Ki·∫øn th·ª©c c∆° s·ªü kh·ªëi ng√†nh",
    "Ki·∫øn th·ª©c c∆° s·ªü ng√†nh",
    "Ki·∫øn th·ª©c ng√†nh",
    "Ki·∫øn th·ª©c t·ª± ch·ªçn",
    "Th·ª±c t·∫≠p v√† h·ªçc ph·∫ßn t·ªët nghi·ªáp",
    "M√¥n h·ªçc ƒëi·ªÅu ki·ªán", # M·∫∑c d√π 0 TC nh∆∞ng v·∫´n l√† m·ªôt lo·∫°i
    "Chu·∫©n ƒë·∫ßu ra" # M·∫∑c d√π 3 TC nh∆∞ng c√≥ th·ªÉ l√† m√¥n ƒë·∫∑c bi·ªát
]

GRADUATION_REQUIREMENTS = {
    # C√°c kh·ªëi ki·∫øn th·ª©c c√≥ t√≠n ch·ªâ
    "L√Ω lu·∫≠n ch√≠nh tr·ªã": 13,
    "K·ªπ nƒÉng": 3,
    "Ngo·∫°i ng·ªØ": 6,
    "Khoa h·ªçc t·ª± nhi√™n v√† tin h·ªçc": 21,
    "Gi√°o d·ª•c qu·ªëc ph√≤ng an ninh": 11,
    "Gi√°o d·ª•c th·ªÉ ch·∫•t": 34,
    "Ki·∫øn th·ª©c c∆° s·ªü kh·ªëi ng√†nh": 31,
    "Ki·∫øn th·ª©c c∆° s·ªü ng√†nh": 22,
    "Ki·∫øn th·ª©c ng√†nh": 39,
    "Ki·∫øn th·ª©c t·ª± ch·ªçn": 27,
    "Th·ª±c t·∫≠p v√† h·ªçc ph·∫ßn t·ªët nghi·ªáp": 13,
    # T·ªïng t√≠n ch·ªâ ƒë∆∞·ª£c t√≠nh t·ª± ƒë·ªông t·ª´ c√°c m·ª•c tr√™n
}
# T√≠nh to√°n t·ªïng t√≠n ch·ªâ y√™u c·∫ßu
total_required_credits = sum(GRADUATION_REQUIREMENTS.values())
GRADUATION_REQUIREMENTS["T·ªïng t√≠n ch·ªâ t√≠ch l≈©y"] = total_required_credits


DEFAULT_TEMPLATE = pd.DataFrame([
    {"Course": "M√¥n h·ªçc 1", "Credits": 3.0, "Grade": "A", "Category": "Ki·∫øn th·ª©c ng√†nh"},
    {"Course": "M√¥n h·ªçc 2", "Credits": 3.0, "Grade": "B", "Category": "Khoa h·ªçc t·ª± nhi√™n v√† tin h·ªçc"},
])

# -----------------------------
# C√ÅC H√ÄM TI·ªÜN √çCH (Gi·ªØ nguy√™n)
# -----------------------------
@st.cache_data
def to_csv(df: pd.DataFrame) -> bytes:
    return df.to_csv(index=False).encode("utf-8")

def calc_gpa(df: pd.DataFrame, grade_map: Dict[str, float]) -> float:
    if df.empty: return 0.0
    work = df.copy()
    fail_grades = [grade for grade, point in grade_map.items() if point == 0.0]
    work_passed = work[~work["Grade"].isin(fail_grades)]
    if work_passed.empty: return 0.0
    work_passed["Points"] = work_passed["Grade"].map(grade_map).fillna(0.0)
    work_passed["QP"] = work_passed["Points"] * pd.to_numeric(work_passed["Credits"], errors="coerce").fillna(0.0)
    total_credits = pd.to_numeric(work_passed["Credits"], errors="coerce").fillna(0.0).sum()
    if total_credits <= 0: return 0.0
    return (work_passed["QP"].sum()) / total_credits

def check_academic_warning(semester_number: int, sgpa: float, cumulative_f_credits: float, previous_warning_level: int) -> Tuple[int, str, List[str]]:
    reasons, is_warning_condition_met = [], False
    if semester_number == 1 and sgpa < 0.80: is_warning_condition_met = True; reasons.append(f"SGPA h·ªçc k·ª≥ 1 ({sgpa:.2f}) < 0.80")
    elif semester_number > 1 and sgpa < 1.00: is_warning_condition_met = True; reasons.append(f"SGPA ({sgpa:.2f}) < 1.00")
    if cumulative_f_credits > 24: is_warning_condition_met = True; reasons.append(f"T·ªïng t√≠n ch·ªâ n·ª£ ({cumulative_f_credits}) > 24")
    
    current_warning_level = 0
    if is_warning_condition_met: current_warning_level = min(previous_warning_level + 1, 3)
    if current_warning_level > 0: return current_warning_level, f"C·∫£nh b√°o h·ªçc t·∫≠p M·ª©c {current_warning_level}", reasons
    return 0, "ƒê·∫°t y√™u c·∫ßu", []

def calculate_progress(all_sems_data: List[pd.DataFrame], requirements: Dict, grade_map: Dict):
    if not any(not df.empty for df in all_sems_data): return pd.DataFrame()
    
    master_df = pd.concat(all_sems_data, ignore_index=True)
    fail_grades = [grade for grade, point in grade_map.items() if point == 0.0]
    passed_df = master_df[~master_df["Grade"].isin(fail_grades)].copy()
    passed_df["Credits"] = pd.to_numeric(passed_df["Credits"], errors="coerce").fillna(0.0)
    
    progress_data = []
    total_completed = passed_df["Credits"].sum()
    total_required = requirements.get("T·ªïng t√≠n ch·ªâ t√≠ch l≈©y", 1)
    progress_data.append({"Y√™u c·∫ßu": "T·ªïng t√≠n ch·ªâ", "ƒê√£ ho√†n th√†nh": total_completed, "Y√™u c·∫ßu": total_required})

    category_credits = passed_df.groupby("Category")["Credits"].sum()
    for category_name, required in requirements.items():
        if category_name == "T·ªïng t√≠n ch·ªâ t√≠ch l≈©y": continue
        completed = category_credits.get(category_name, 0.0)
        progress_data.append({"Y√™u c·∫ßu": category_name, "ƒê√£ ho√†n th√†nh": completed, "Y√™u c·∫ßu": required})
    
    df = pd.DataFrame(progress_data)
    df["C√≤n l·∫°i"] = (df["Y√™u c·∫ßu"] - df["ƒê√£ ho√†n th√†nh"]).clip(lower=0)
    df["Ti·∫øn ƒë·ªô"] = (df["ƒê√£ ho√†n th√†nh"] / df["Y√™u c·∫ßu"]).clip(0, 1) if df["Y√™u c·∫ßu"].all() > 0 else 0
    return df

# -----------------------------
# SIDEBAR (Gi·ªØ nguy√™n)
# -----------------------------
st.sidebar.title("‚öôÔ∏è C√†i ƒë·∫∑t")
scale_name = st.sidebar.selectbox("Thang ƒëi·ªÉm", list(PRESET_SCALES.keys()) + ["T√πy ch·ªânh‚Ä¶"], index=0)
if scale_name == "T√πy ch·ªânh‚Ä¶":
    st.sidebar.caption("Nh·∫≠p b·∫£ng quy ƒë·ªïi ƒëi·ªÉm ch·ªØ sang ƒëi·ªÉm s·ªë.")
    if "custom_scale" not in st.session_state: st.session_state.custom_scale = pd.DataFrame({"Grade": ["A", "B", "C", "D", "F"], "Point": [4.0, 3.0, 2.0, 1.0, 0.0]})
    st.session_state.custom_scale = st.sidebar.data_editor(st.session_state.custom_scale, num_rows="dynamic", use_container_width=True, hide_index=True, column_config={"Grade": st.column_config.TextColumn("ƒêi·ªÉm ch·ªØ", required=True), "Point": st.column_config.NumberColumn("ƒêi·ªÉm s·ªë", required=True)})
    grade_map = {r.Grade: float(r.Point) for r in st.session_state.custom_scale.itertuples(index=False) if pd.notna(r.Grade) and pd.notna(r.Point)}
else: grade_map = PRESET_SCALES[scale_name]
st.sidebar.divider()
st.sidebar.subheader("üìÅ Nh·∫≠p / Xu·∫•t File")
if st.sidebar.button("‚¨áÔ∏è Xu·∫•t to√†n b·ªô d·ªØ li·ªáu (CSV)"):
    all_dfs = []
    for i, df in enumerate(st.session_state.get("sems", [])):
        df_copy = df.copy(); df_copy["Semester"] = i + 1; all_dfs.append(df_copy)
    if any(not df.empty for df in all_dfs):
        master_df = pd.concat(all_dfs, ignore_index=True)
        st.sidebar.download_button(label="T·∫£i v·ªÅ file t·ªïng h·ª£p", data=to_csv(master_df), file_name="GPA_data_all_semesters.csv", mime="text/csv", use_container_width=True)
    else: st.sidebar.warning("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.")
def on_file_upload(): st.session_state.file_processed = False
upload = st.sidebar.file_uploader("Nh·∫≠p file CSV (c√≥ c·ªôt Semester, Category)", type=["csv"], key="uploader", on_change=on_file_upload)

# -----------------------------
# GIAO DI·ªÜN CH√çNH
# -----------------------------
st.title("üéì H·ªá th·ªëng T∆∞ v·∫•n H·ªçc t·∫≠p")
if upload is not None and not st.session_state.get('file_processed', False):
    try:
        df_up = pd.read_csv(upload, encoding='utf-8')
        needed = {"Course", "Credits", "Grade", "Semester", "Category"}
        if not needed.issubset(df_up.columns): st.warning("File CSV ph·∫£i c√≥ c√°c c·ªôt: Course, Credits, Grade, Semester, Category")
        else:
            df_up["Semester"] = pd.to_numeric(df_up["Semester"], errors="coerce").fillna(1).astype(int)
            max_sem = df_up["Semester"].max()
            st.session_state.n_sem_input = max_sem
            new_sems = []
            for i in range(1, max_sem + 1):
                sem_df = df_up[df_up["Semester"] == i][["Course", "Credits", "Grade", "Category"]].reset_index(drop=True)
                if sem_df.empty: sem_df = pd.DataFrame(columns=["Course", "Credits", "Grade", "Category"])
                new_sems.append(sem_df)
            st.session_state.sems = new_sems
            st.session_state.file_processed = True
            st.success(f"ƒê√£ nh·∫≠p v√† ph√¢n b·ªï d·ªØ li·ªáu cho {max_sem} h·ªçc k·ª≥.")
            st.rerun()
    except Exception as e: st.error(f"Kh√¥ng th·ªÉ ƒë·ªçc file CSV: {e}"); st.session_state.file_processed = True

st.header("üìä B·∫£ng t·ªïng quan Ti·∫øn ƒë·ªô T·ªët nghi·ªáp")
if "sems" in st.session_state:
    progress_df = calculate_progress(st.session_state.sems, GRADUATION_REQUIREMENTS, grade_map)
    if not progress_df.empty:
        total_progress = progress_df.iloc[0]
        st.subheader(f"T·ªïng quan: {total_progress['ƒê√£ ho√†n th√†nh']:.0f} / {total_progress['Y√™u c·∫ßu']:.0f} t√≠n ch·ªâ ƒë√£ t√≠ch l≈©y")
        st.progress(total_progress['Ti·∫øn ƒë·ªô'], text=f"{total_progress['Ti·∫øn ƒë·ªô']:.1%}")
        st.markdown("---")
        detail_df = progress_df[progress_df['Y√™u c·∫ßu'] > 0].iloc[1:].reset_index(drop=True)
        if not detail_df.empty:
            st.subheader("Chi ti·∫øt theo kh·ªëi ki·∫øn th·ª©c")
            # N√ÇNG C·∫§P: Chia th√†nh 2 c·ªôt ƒë·ªÉ hi·ªÉn th·ªã g·ªçn g√†ng
            left_col, right_col = st.columns(2)
            for i, row in detail_df.iterrows():
                target_col = left_col if i % 2 == 0 else right_col
                with target_col:
                    st.metric(label=str(row["Y√™u c·∫ßu"]), value=f"{row['ƒê√£ ho√†n th√†nh']:.0f} / {row['Y√™u c·∫ßu']:.0f}", delta=f"C√≤n l·∫°i: {row['C√≤n l·∫°i']:.0f}", delta_color="inverse")
                    st.progress(row['Ti·∫øn ƒë·ªô'])
    else: st.info("Ch∆∞a c√≥ d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch ti·∫øn ƒë·ªô.")
st.divider()

n_sem = st.number_input("S·ªë h·ªçc k·ª≥ (semesters)", min_value=1, max_value=20, value=st.session_state.get('n_sem_input', 8), step=1, key="n_sem_input")
if "sems" not in st.session_state or len(st.session_state.sems) != n_sem:
    current_sems = st.session_state.get("sems", [])
    current_len = len(current_sems)
    if current_len < n_sem: current_sems += [DEFAULT_TEMPLATE.copy() for _ in range(n_sem - current_len)]
    else: current_sems = current_sems[:n_sem]
    st.session_state.sems = current_sems
    st.rerun()

sem_tabs = st.tabs([f"H·ªçc k·ª≥ {i+1}" for i in range(n_sem)])
per_sem_gpa, per_sem_cred, warning_history = [], [], []
cumulative_f_credits, previous_warning_level = 0.0, 0
fail_grades = [grade for grade, point in grade_map.items() if point == 0.0]

for i, tab in enumerate(sem_tabs):
    with tab:
        st.write(f"### B·∫£ng ƒëi·ªÉm H·ªçc k·ª≥ {i+1}")
        df_with_delete = st.session_state.sems[i].copy(); df_with_delete.insert(0, "X√≥a", False)
        cols_action = st.columns([0.7, 0.15, 0.15]);
        with cols_action[1]:
            if st.button("üóëÔ∏è X√≥a m√¥n ƒë√£ ch·ªçn", key=f"delete_{i}", use_container_width=True):
                edited_df_state = st.session_state[f"editor_{i}"]
                rows_to_keep = [row for _, row in edited_df_state.iterrows() if not row["X√≥a"]]
                st.session_state.sems[i] = pd.DataFrame(rows_to_keep).drop(columns=["X√≥a"]); st.rerun()
        with cols_action[2]:
            if st.button("üîÑ Reset h·ªçc k·ª≥", key=f"reset_{i}", use_container_width=True):
                st.session_state.sems[i] = DEFAULT_TEMPLATE.copy(); st.rerun()
        grade_options = list(grade_map.keys())
        if not grade_options: st.warning("Ch∆∞a c√≥ thang ƒëi·ªÉm."); grade_options = ["..."]
        edited = st.data_editor(df_with_delete, num_rows="dynamic", hide_index=True, use_container_width=True,
            column_config={
                "X√≥a": st.column_config.CheckboxColumn(width="small"), "Course": st.column_config.TextColumn("T√™n m√¥n h·ªçc", width="large", required=True),
                "Credits": st.column_config.NumberColumn("S·ªë t√≠n ch·ªâ", min_value=0.0, step=0.5, required=True),
                "Grade": st.column_config.SelectboxColumn("ƒêi·ªÉm ch·ªØ", options=grade_options, required=True),
                "Category": st.column_config.SelectboxColumn("Ph√¢n lo·∫°i", options=DEFAULT_COURSE_CATEGORIES, required=True)
            }, key=f"editor_{i}")
        st.session_state.sems[i] = edited.drop(columns=["X√≥a"])

        current_sem_df = st.session_state.sems[i]
        gpa = calc_gpa(current_sem_df, grade_map); per_sem_gpa.append(gpa)
        creds = pd.to_numeric(current_sem_df["Credits"], errors="coerce").fillna(0.0).sum(); per_sem_cred.append(float(creds))
        current_f_credits = pd.to_numeric(current_sem_df[current_sem_df["Grade"].isin(fail_grades)]["Credits"], errors="coerce").fillna(0.0).sum()
        cumulative_f_credits += current_f_credits
        warning_level, msg, reasons = check_academic_warning(i + 1, gpa, cumulative_f_credits, previous_warning_level)
        warning_history.append({"H·ªçc k·ª≥": i + 1, "M·ª©c C·∫£nh b√°o": warning_level, "L√Ω do": ", ".join(reasons) if reasons else "Kh√¥ng c√≥"})
        m1, m2, m3 = st.columns(3)
        m1.metric("GPA h·ªçc k·ª≥ (SGPA)", f"{gpa:.3f}"); m2.metric("T·ªïng t√≠n ch·ªâ h·ªçc k·ª≥", f"{creds:.2f}"); m3.metric("T√≠n ch·ªâ n·ª£ t√≠ch l≈©y", f"{cumulative_f_credits:.2f}")
        st.divider()
        if warning_level > 0: st.warning(f"**{msg}**\n\n*L√Ω do: {' & '.join(reasons)}*")
        else: st.success(f"**‚úÖ {msg}**")
        previous_warning_level = warning_level

all_passed_dfs = [df[~df["Grade"].isin(fail_grades)] for df in st.session_state.sems]
master_passed_df = pd.concat(all_passed_dfs) if all_passed_dfs else pd.DataFrame()
cgpa = calc_gpa(master_passed_df, grade_map)
total_passed_credits = pd.to_numeric(master_passed_df['Credits'], errors='coerce').fillna(0).sum()

st.divider()
colA, colB, colC = st.columns([1, 1, 2])
colA.metric("üéØ GPA T√≠ch l≈©y (CGPA)", f"{cgpa:.3f}")
colB.metric("üìö T·ªïng t√≠n ch·ªâ ƒë√£ qua", f"{total_passed_credits:.2f}")

with colC:
    if per_sem_gpa and all(c >= 0 for c in per_sem_cred):
        try:
            fig, ax = plt.subplots(); x = np.arange(1, len(per_sem_gpa) + 1)
            ax.plot(x, per_sem_gpa, marker="o", linestyle="-", color='b')
            ax.set_xlabel("H·ªçc k·ª≥"); ax.set_ylabel("GPA (SGPA)"); ax.set_title("Xu h∆∞·ªõng GPA theo h·ªçc k·ª≥")
            ax.set_xticks(x); ax.grid(True, linestyle=":", linewidth=0.5)
            ax.set_ylim(bottom=0, top=max(4.1, max(per_sem_gpa) * 1.1 if per_sem_gpa and any(v > 0 for v in per_sem_gpa) else 4.1))
            st.pyplot(fig, use_container_width=True)
        except Exception: st.info("Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ v·∫Ω bi·ªÉu ƒë·ªì.")

with st.expander("‚ùì H∆∞·ªõng d·∫´n, C√°ch t√≠nh & L·ªãch s·ª≠ c·∫£nh b√°o"):
    st.markdown("##### H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng")
    st.markdown("""
- **Nh·∫≠p/Xu·∫•t file:** File CSV ph·∫£i c√≥ c√°c c·ªôt: `Course`, `Credits`, `Grade`, `Semester`, `Category`.
- **Th√™m/x√≥a m√¥n h·ªçc:** D√πng n√∫t `+` ƒë·ªÉ th√™m v√† tick v√†o √¥ "X√≥a" r·ªìi nh·∫•n n√∫t "üóëÔ∏è X√≥a m√¥n ƒë√£ ch·ªçn" ƒë·ªÉ x√≥a.
""")
    st.markdown("---")
    st.markdown("##### L·ªãch s·ª≠ c·∫£nh b√°o h·ªçc t·∫≠p")
    st.dataframe(pd.DataFrame(warning
